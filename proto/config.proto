/*
    GSP for the Taurion blockchain game
    Copyright (C) 2019-2020  Autonomous Worlds Ltd

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <https://www.gnu.org/licenses/>.
*/

syntax = "proto2";

import "character.proto";
import "combat.proto";
import "geometry.proto";

package pxd.proto;

/**
 * General modification something can give to an existing numerical value,
 * e.g. an increase to a vehicle speed or combat damage.
 */
message StatModifier
{

  /**
   * Relative change to the base value, in percent.  This is added (or
   * subtracted if negative), so not a multiplicative factor.
   */
  optional sint32 percent = 1;

}

/* ************************************************************************** */

/**
 * Data about the ability to refine items of this type to other item types
 * (i.e. raw materials into refined resources).
 */
message RefiningData
{

  /** Number of instances going into one "refining unit".  */
  optional uint32 input_units = 1;

  /** Base cost (burnt) in vCHI for one refinement step.  */
  optional uint32 cost = 2;

  /**
   * The outputs (as item type, amount) for one refining step (i.e.
   * "input_units" input units).
   */
  map<string, uint32> outputs = 3;

}

/**
 * Specific data for blueprint items defining the modalities for
 * constructing stuff from it.
 */
message BlueprintData
{

  /** The item type constructed from the blueprint.  */
  optional string for_item = 1;

  /**
   * Whether or not this is an original.  Originals can be copied and
   * can be used an unlimited amount of time, whereas copies (if not
   * originals) cannot be copied themselves and can only be used once
   * to build an item.
   */
  optional bool original = 2;

}

/**
 * Data about the ability to reverse-engineer an item to obtain blueprints.
 */
message RevEngData
{

  /** Cost (in vCHI) for a reveng attempt.  */
  optional uint32 cost = 1;

  /**
   * Types of items (most likely blueprint originals) that can be obtained
   * from this through reverse engineering.
   */
  repeated string possible_outputs = 2;

}

/**
 * Data specific about items that are vehicles.
 */
message VehicleData
{

  /** Base cargo space of this vehicle.  */
  optional uint32 cargo_space = 1;

  /** Base movement speed (in milli-tiles per block).  */
  optional uint32 speed = 2;

  /** Basic regeneration data and max HP.  */
  optional RegenData regen_data = 3;

  /** Basic combat data (including attacks mostly).  */
  optional CombatData combat_data = 4;

  /** Base mining speed for the vehicle.  */
  optional MiningData.Speed mining_rate = 5;

  /**
   * Number of equipment slots of each type.  The slot types are just strings
   * which have to be matched between here and the fitment configs.  The valid
   * values are "high", "mid" and "low".  Unfortunately we cannot use enum
   * values as they can't be keys in protocol buffer maps.
   */
  map<string, uint32> equipment_slots = 6;

}

/**
 * Data specific about items that are fitments.
 */
message FitmentData
{

  /** The type of slot this requires.  */
  optional string slot = 1;

  /** An attack this does.  */
  optional Attack attack = 2;

  /** Modification to the cargo space.  */
  optional StatModifier cargo_space = 3;

  /** Modification to the movement speed.  */
  optional StatModifier speed = 4;

  /** Modification to max armour HP.  */
  optional StatModifier max_armour = 5;

  /** Modification to max shield HP.  */
  optional StatModifier max_shield = 6;

  /** Modification to shield regeneration rate.  */
  optional StatModifier shield_regen = 7;

  /** Modification of all attack ranges.  */
  optional StatModifier range = 8;

  /** Modification of all attack damages (min and max).  */
  optional StatModifier damage = 9;

  /** Modification to the vehicle's allowed fitment complexity.  */
  optional StatModifier complexity = 10;

}

/**
 * Hardcoded data defining a type of fungible item.
 */
message ItemData
{

  /** The cargo space it uses per unit.  */
  optional uint32 space = 1;

  /** For items that have one, the complexity level.  */
  optional uint32 complexity = 2;

  /** Whether or not this item has an associated blueprint.  */
  optional bool with_blueprint = 3;

  /**
   * The resources required to construct one of this item type, assuming
   * there exists a blueprint for it.
   */
  map<string, uint32> construction_resources = 4;

  oneof type
  {

    /** If this type of item can be refined, then the stats for doing so.  */
    RefiningData refines = 101;

    /** If this is a blueprint, the associated data.  */
    BlueprintData is_blueprint = 102;

    /**
     * If this can be reverse engineered (i.e. is an artefact), the
     * configuration data specifying the corresponding stats.
     */
    RevEngData reveng = 103;

    /** If this is a vehicle item, the specific stats for that.  */
    VehicleData vehicle = 104;

    /** If this is a fitment, the specific stats for that.  */
    FitmentData fitment = 105;

  }

}

/* ************************************************************************** */

/**
 * Hardcoded data defining a type of building.
 */
message BuildingData
{

  /**
   * The enter/exit L1 radius of this building.  Characters can enter
   * the building if they are within this L1 radius of the centre coordinate,
   * and when exiting, they will appear on a random spot within that radius.
   */
  optional uint32 enter_radius = 1;

  /**
   * All tiles that make up the building's shape, in the basic, untransformed
   * way.  The coordinates are relative to the building's centre.
   */
  repeated HexCoord shape_tiles = 2;

  /**
   * Combination of combat and regen data for a building or
   * the foundation.
   */
  message AllCombatData
  {
    optional CombatData combat_data = 1;
    optional RegenData regen_data = 2;
  }

  /**
   * Combat data for the foundation of the building alone.
   */
  optional AllCombatData foundation = 3;

  /**
   * Combat data for the full building (after construction is done).
   */
  optional AllCombatData full_building = 4;

  /**
   * Required resources and other data for constructing the building.
   */
  message ConstructionData
  {

    /**
     * Resources (keyed by item type, value is the quantity) required to
     * lay the foundation.
     */
    map<string, uint32> foundation = 1;

    /** Resources for upgrading the foundation to the full building.  */
    map<string, uint32> construction = 2;

    /**
     * Number of blocks the construction (from foundation to full building)
     * takes for this type.
     */
    optional uint32 blocks = 3;

  }

  /** The data for constructing this building.  */
  optional ConstructionData construction = 5;

  /**
   * The set of services offered by a building.  Since "false" is the default
   * value for a boolean field, only those services that are offered need to
   * be listed in the actual config data.
   */
  message Services
  {
    optional bool refining = 1;
    optional bool armour_repair = 2;
    optional bool reverse_engineering = 3;
    optional bool blueprint_copy = 4;
    optional bool item_construction = 5;
    optional bool vehicle_construction = 6;
  }

  /** Services this building type offers.  */
  optional Services offered_services = 6;

}

/* ************************************************************************** */

/**
 * Data for the resource distribution on the map (when prospecting).
 * This is based on multiple "areas" where one or two resources occur.
 * Each area has a central x/y coordinate.  Then within a core L1 radius
 * around this area, those resources appear with "full chance".  Towards
 * an outer radius, the chance falls off to zero linearly.  If multiple
 * areas overlap (or there are two resources in one), then we pick between
 * them based on their chances as weights.
 *
 * The radii themselves are just constants in the source code.  The proto
 * data in this message holds the more complex things, like the list of
 * areas and the amounts per resource type.
 */
message ResourceDistribution
{

  /**
   * The "base amount" of resource to be found for each resource type in
   * a region.  These numbers fall off to zero (with a minimum of one unit)
   * as with the chance.  If we denote the resulting number by X, then the
   * actual amount found will be uniformly chosen from [X, 2X].
   */
  map<string, uint32> base_amounts = 1;

  /**
   * One area where resources can be found.
   */
  message Area
  {

    /** The centre coordinate of the area.  */
    optional HexCoord centre = 1;

    /** The type(s) of resources to be found here.  */
    repeated string resources = 2;

  }

  /** Resource areas.  */
  repeated Area areas = 2;

}

/* ************************************************************************** */

/**
 * The hardcoded "configuration data" for Taurion.  This includes all data
 * that describes read-only aspects of the game, like known item or vehicle
 * types and stats for them.
 *
 * An instance of this proto is populated from text format encoded in
 * roconfig/<files>.pb.text and made available to all parts of the code.
 */
message ConfigData
{

  /** Known types of fungible items.  */
  map<string, ItemData> fungible_items = 1;

  /** Known types of buildings.  */
  map<string, BuildingData> building_types = 2;

  /** Distribution of resources for prospecting.  */
  optional ResourceDistribution resource_dist = 3;

}
